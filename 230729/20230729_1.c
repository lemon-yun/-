

#include <stdio.h>

int main_1()
{
	//sizeof计算数组字符串时会计算\0
	//指针p是首元素的地址，&p是p的地址
	//指针 p[0] 就等于*(p + 0)
	//&、siseof 对数组都是取得整个数组
	//所以&arr+1是跳过整个数组
	//二维数组arr[0]指的是第一行第一个元素的地址
	//sizeof(arr[0])会计算这一行的大小
	//arr[0]+1指的是第一行第二个元素的地址
	//sizeof(arr[0]+1)结果是第一行第二个元素的地址的大小
	//sizeof(*(arr[0]+1))结果是第一行第二个元素的大小
	//sizeof(arr+1),arr没有单独放在sizeof的括号内，此时arr指的是二维数组第一个元素
	//即第一行的地址，+1后指的第二行的地址，地址的大小4or8
	//&arr[0]+1是第二行的地址，大小是4or8


	int a[4] = { 1,2,3,4 };
	int* p = (int*)((int)a + 1);
	printf("%#x", *p);//x86运行
	//小端存储，数组里面是 01  00  00  00  02  00  00  00  03  00  00  00  04  00  00  00
	// 假设地址为        x01 x02 x03 x04 x05 x06 x07 x08 x09 x0a x0b x0c x0d x0e x0f x10
 	//a原本指首元素的地址x01(包含到x04),强制类型转换为int后加1就变为x02(只是x02)
	//再转换为int* x02(包含到x05),即x02~x05被认为是一个元素
	//解引用后输出就是(0)2000000(小端存储)
	return 0;
}


int main_2()
{
	int a[5][5];
	int(*p)[4];
	p = a;//p会以四个为一组将a分组
	printf("%p, %d", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
	//%p，会直接将-4的补码以16进制打印出来
	return 0;
}

//二维数组需要解引用两次才会得到具体的值，
//int a[2][5] = {1,2,3,4,5,6,7,8,9,10}
//a+1和*(a+1)都是地址相同，但含义不同，a+1是第二行的地址，*(a+1)是第二行第一个元素的地址